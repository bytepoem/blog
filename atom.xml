<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Byte Poem</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://www.bytepoem.com/"/>
  <updated>2020-04-21T17:30:24.747Z</updated>
  <id>https://www.bytepoem.com/</id>
  
  <author>
    <name>才子</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用 Grafana 以及 node_exporter 中的 tcpstat 收集器监控 TCP 连接各个状态的数量</title>
    <link href="https://www.bytepoem.com/2020/04/21/grafana-tcp-status/"/>
    <id>https://www.bytepoem.com/2020/04/21/grafana-tcp-status/</id>
    <published>2020-04-21T15:27:46.000Z</published>
    <updated>2020-04-21T17:30:24.747Z</updated>
    
    <content type="html"><![CDATA[<p>在经历了 CLOSE_WAIT 增多而导致的服务器性能下降的问题之后，为了能实时监控 TCP 各个状态的数量，我选择了 Grafana 以及 node_exporter 的 tcpstat 收集器。</p><p>关于 node_exporter 就不多做介绍了，想详细了解的同学可以访问 Github 上的仓库 👉 <a href="https://github.com/prometheus/node_exporter">Node exporter</a> 。</p><a id="more"></a><p>简单介绍一下 <strong>tcpstat</strong> 收集器，是 node_exporter 自带的收集器，适用的环境是 Linux，本质是从 <code>/proc/net/tcp</code> 以及 <code>/proc/net/tcp6</code> 获取 TCP 连接状态的信息。需要注意的是当前版本（0.18.1）在高负载下会出现性能问题，具体表现就是采集地址无法访问导致 Prometheus 无法获取数据。另外，tcpstat 收集器是<strong>默认不开启</strong>，所以启动的时候需要带上 <code>--collector.tcpstat</code> 参数（可以通过参数 <code>-h</code> 了解）。</p><p><img src="https://i.loli.net/2020/04/21/uGJ3iLVBTrMt7Nc.png" alt="tcpstat"></p><p>启动好 node_exporter 并开启 tcpstat 收集器之后，我们就可以前往 Grafana 设置监控面板了。</p><p>在新建 panel 中添加一个 Query，查询语句：<code>node_tcp_connection_states{instance=&quot;localhost:9100&quot;</code></p><ul><li>其中 <code>node_tcp_connection_states</code> 是 TCP 连接状态的 metric 的名称，这个怎么来的呢，<del>我是瞎蒙的</del>，因为 Grafana 自带语法提示，所以输入 <code>tcp</code> 就可以直接找到（）。而 <code>9100</code> 就是 node_exporter 的默认端口号。</li></ul><p><img src="https://i.loli.net/2020/04/21/H1TsKtjidBymIwl.png" alt="Metrics"></p><p>完整的 Query 就是下面这个样子。</p><p><img src="https://i.loli.net/2020/04/21/7ctZ5BUDhCRE8wP.png" alt="Query"></p><p>最后查询出来的效果如下：</p><p><img src="https://i.loli.net/2020/04/21/1p34hfakFzLo5DN.png" alt="panel"></p><p>tcpstat 收集器相关的实现在这里 👉 <a href="https://github.com/prometheus/node_exporter/blob/master/collector/tcpstat_linux.go">tcpstat_linux.go</a> 。下面贴一下主要代码片段。</p><p>首先 tcpstat 定义了 TCP 连接各个状态的常量，即我们可以收集（监控）到的信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    <span class="comment">// TCP_ESTABLISHED</span></span><br><span class="line">    tcpEstablished tcpConnectionState = <span class="literal">iota</span> + <span class="number">1</span></span><br><span class="line">    <span class="comment">// TCP_SYN_SENT</span></span><br><span class="line">    tcpSynSent</span><br><span class="line">    <span class="comment">// TCP_SYN_RECV</span></span><br><span class="line">    tcpSynRecv</span><br><span class="line">    <span class="comment">// TCP_FIN_WAIT1</span></span><br><span class="line">    tcpFinWait1</span><br><span class="line">    <span class="comment">// TCP_FIN_WAIT2</span></span><br><span class="line">    tcpFinWait2</span><br><span class="line">    <span class="comment">// TCP_TIME_WAIT</span></span><br><span class="line">    tcpTimeWait</span><br><span class="line">    <span class="comment">// TCP_CLOSE</span></span><br><span class="line">    tcpClose</span><br><span class="line">    <span class="comment">// TCP_CLOSE_WAIT</span></span><br><span class="line">    tcpCloseWait</span><br><span class="line">    <span class="comment">// TCP_LAST_ACK</span></span><br><span class="line">    tcpLastAck</span><br><span class="line">    <span class="comment">// TCP_LISTEN</span></span><br><span class="line">    tcpListen</span><br><span class="line">    <span class="comment">// TCP_CLOSING</span></span><br><span class="line">    tcpClosing</span><br><span class="line">    <span class="comment">// TCP_RX_BUFFER</span></span><br><span class="line">    tcpRxQueuedBytes</span><br><span class="line">    <span class="comment">// TCP_TX_BUFFER</span></span><br><span class="line">    tcpTxQueuedBytes</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>接着定义了收集器的相关信息，比如上边提到的 metric 的名称 <code>node_tcp_connection_states</code> 以及提供的模板变量 <code>state</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">NewTCPStatCollector</span><span class="params">(logger log.Logger)</span> <span class="params">(Collector, error)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &amp;tcpStatCollector&#123;</span><br><span class="line">        desc: typedDesc&#123;prometheus.NewDesc(</span><br><span class="line">            prometheus.BuildFQName(namespace, <span class="string">"tcp"</span>, <span class="string">"connection_states"</span>),</span><br><span class="line">            <span class="string">"Number of connection states."</span>,</span><br><span class="line">            []<span class="keyword">string</span>&#123;<span class="string">"state"</span>&#125;, <span class="literal">nil</span>,</span><br><span class="line">        ), prometheus.GaugeValue&#125;,</span><br><span class="line">        logger: logger,</span><br><span class="line">    &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面两个方法就是从 <code>/proc/net/tcp</code> 以及 <code>/proc/net/tcp6</code> 这两个文件获取 TCP 连接状态的信息并转化为 metric。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(c *tcpStatCollector)</span> <span class="title">Update</span><span class="params">(ch <span class="keyword">chan</span>&lt;- prometheus.Metric)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">    tcpStats, err := getTCPStats(procFilePath(<span class="string">"net/tcp"</span>))</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't get tcpstats: %s"</span>, err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// if enabled ipv6 system</span></span><br><span class="line">    tcp6File := procFilePath(<span class="string">"net/tcp6"</span>)</span><br><span class="line">    <span class="keyword">if</span> _, hasIPv6 := os.Stat(tcp6File); hasIPv6 == <span class="literal">nil</span> &#123;</span><br><span class="line">        tcp6Stats, err := getTCPStats(tcp6File)</span><br><span class="line">        <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> fmt.Errorf(<span class="string">"couldn't get tcp6stats: %s"</span>, err)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> st, value := <span class="keyword">range</span> tcp6Stats &#123;</span><br><span class="line">            tcpStats[st] += value</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> st, value := <span class="keyword">range</span> tcpStats &#123;</span><br><span class="line">        ch &lt;- c.desc.mustNewConstMetric(value, st.String())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getTCPStats</span><span class="params">(statsFile <span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">map</span>[tcpConnectionState]<span class="keyword">float64</span>, error)</span></span> &#123;</span><br><span class="line">    file, err := os.Open(statsFile)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parseTCPStats(file)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本文到这里结束啦，主要介绍了如何利用 Grafana + node_exporter.tcpstat 的方式实时监控 TCP 连接状态信息，如果大家有其他的方式，欢迎下方留言讨论。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在经历了 CLOSE_WAIT 增多而导致的服务器性能下降的问题之后，为了能实时监控 TCP 各个状态的数量，我选择了 Grafana 以及 node_exporter 的 tcpstat 收集器。&lt;/p&gt;
&lt;p&gt;关于 node_exporter 就不多做介绍了，想详细了解的同学可以访问 Github 上的仓库 👉 &lt;a href=&quot;https://github.com/prometheus/node_exporter&quot;&gt;Node exporter&lt;/a&gt; 。&lt;/p&gt;
    
    </summary>
    
    
      <category term="grafana" scheme="https://www.bytepoem.com/categories/grafana/"/>
    
    
      <category term="grafana" scheme="https://www.bytepoem.com/tags/grafana/"/>
    
      <category term="node_exporter" scheme="https://www.bytepoem.com/tags/node-exporter/"/>
    
      <category term="tcp" scheme="https://www.bytepoem.com/tags/tcp/"/>
    
  </entry>
  
  <entry>
    <title>记录一次服务器出现大量 CLOSE_WAIT 的原因排查过程以及解决办法</title>
    <link href="https://www.bytepoem.com/2020/04/20/to-many-close-wait/"/>
    <id>https://www.bytepoem.com/2020/04/20/to-many-close-wait/</id>
    <published>2020-04-20T15:28:54.000Z</published>
    <updated>2020-04-20T16:01:39.283Z</updated>
    
    <content type="html"><![CDATA[<p>最近在服务器上发现有大量的 CLOSE_WAIT 存在，排查发现是 Python 爬虫中 requests 导致的。</p><h3 id="1-CLOSE-WAIT"><a href="#1-CLOSE-WAIT" class="headerlink" title="1. CLOSE WAIT"></a>1. CLOSE WAIT</h3><p>简单来说，TCP 连接断开时需要进行“四次挥手”（建立连接是“三次握手”），TCP 连接的两端都可以发起关闭连接的请求，若其中一端发起了关闭连接，但另外一端没有关闭连接，那么该连接就会处于 CLOSE_WAIT 状态。</p><a id="more"></a><p><img src="https://i.loli.net/2020/04/20/tevTiJ9cWzSmQdV.png" alt="TCP四次挥手"></p><p>四次握手的流程：</p><ol><li>Client 发送一个 FIN，用来关闭客户端到服务器的数据传送（报文段 1）</li><li>Server 收到这个 FIN，发回一个 ACK，确认需要为收到的序号加 1（报文段 5）。和 SYN 一样，一个 FIN 占用一个序号</li><li>Server 关闭 Client 的连接，发送一个 FIN 给客户端（报文段 6）</li><li>Client 发回 ACK 报文确认，并将确认序号设为收到的序号加 1（报文段 4）</li></ol><h3 id="2-原因"><a href="#2-原因" class="headerlink" title="2. 原因"></a>2. 原因</h3><p>通常来说，CLOSE_WAIT 在服务器停留的时间很短，且只会发生在被动关闭连接的一端。除非 Kill 掉进程，否则它是不会消失的，意味着一直占用资源。如果发现有大量的 CLOSE_WAIT，那就是被动关闭的一方没有及时发送 FIN，一般来说有以下几种可能：</p><ul><li>代码问题：请求的时候没有显式关闭 Socket 连接，或者死循环导致关闭连接的代码没有执行到，即 FIN 包没有发出，导致 CLOSE_WAIT 不断累积</li><li>响应过慢 / 超时设置过小：双方连接不稳定，一方 Timeout，另外一方还在处理逻辑，导致 Close 被延后</li></ul><h3 id="3-排查"><a href="#3-排查" class="headerlink" title="3. 排查"></a>3. 排查</h3><h4 id="查看网络连接"><a href="#查看网络连接" class="headerlink" title="查看网络连接"></a>查看网络连接</h4><p>首先我们到服务器上看一下网络连接情况。</p><p>查看 TCP 连接中各个状态数量可以使用以下命令：</p><ul><li><code>netstat -n | awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}&#39;</code><ul><li>ESTABLISHED 表示正在通信</li><li>TIME_WAIT 表示主动关闭</li><li>CLOSE_WAIT 表示被动关闭</li></ul></li></ul><p><img src="https://i.loli.net/2020/04/20/s4St7ZGcPlpmy5E.png" alt="netstat1"></p><p>查看 TCP 连接中 CLOSE_WAIT 的数量可以使用以下命令：</p><ul><li><code>netstat -antop | grep CLOSE_WAIT | wc -l</code><ul><li>netstat 命令用于显示网络状态<ul><li>-a：显示所有连线中的 Socket</li><li>-n：直接使用 IP 地址，而不通过域名服务器</li><li>-t：显示 TCP 传输协议的连线状况</li><li>-o：显示计时器</li><li>-p：显示正在使用 Socket 的程序识别码和程序名称</li></ul></li><li>grep 命令用于查找文件里符合条件的字符串</li><li>wc 命令用于计算字数<ul><li>-l：只显示行数</li></ul></li></ul></li></ul><p><img src="https://i.loli.net/2020/04/20/iftzA3VnX9DyOwx.png" alt="netstat2"></p><p>通过以上命令可以看到服务器上的 CLOSE_WAIT 将近 1w2，这还是我重启了部分运行时间较长的爬虫后的数字，重启前高达 4w，这是个不容小觑的潜在问题。</p><h4 id="梳理-TCP-连接流向"><a href="#梳理-TCP-连接流向" class="headerlink" title="梳理 TCP 连接流向"></a>梳理 TCP 连接流向</h4><p>接着我们可以从上图梳理出 CLOSE_WAIT 的连接流向，命令返回里中的 Foreign Address（第 5 栏）代表对方的 IP 地址，即和我们连接着但是却主动关闭了连接的机器，在我这里即是代理池里边的代理。</p><h4 id="根据项目数据请求流向还原可能场景"><a href="#根据项目数据请求流向还原可能场景" class="headerlink" title="根据项目数据请求流向还原可能场景"></a>根据项目数据请求流向还原可能场景</h4><p>然后我们可以根据项目数据请求流向，还原出可能的场景，在我这里即是 CLOSE_WAIT 都发生在本机爬虫、代理以及目标网站的连接上。毕竟 Program name（最后一栏）都写着 Python 了，且这台服务器上只有爬虫用的 Python。</p><h4 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h4><p>问题出在爬虫就简单了，唯一会发生网络请求的地方就是使用 requests 模块。</p><ul><li>requests 模块会自行处理连接池的问题，且访问完成后出现 CLOSE_WAIT 是正常的，后续会直接复用这些连接。但是如果 CLOSE_WAIT 数量太多且一直下不去，有可能是高并发或者没有关闭的连接一直累积</li><li>如果你直接 get 或者 post 的话会每次都创建一个连接池，且这个连接池只会用一次。所以需要通过全局 session 来使用 requests 模块的连接池功能</li><li>不是任何时候使用连接池都是有效的，仅当你使用了多线程之类的并发才会有效果。毕竟你是单线程的话，里面是串行，一个线程对应一个连接。此外，我们还可以构造好 HttpAdapter 实例用 session.mount 上。HttpAdapter 的常用参数有以下几种：<ul><li>timeout：超时时间</li><li>maxretries：最大尝试次数</li><li>pool_connections：最多连接多少个不同的主机，针对每个 Host 都是独立的连接池</li><li>pool_maxsize：针对每个主机能创建的最大连接数（底层 TCP），由于一个线程对应一个连接，所以一般有多少个线程指定 pool_maxsize 为多少</li></ul></li><li>使用 requests 模块的时候最好将请求放在 try 中，把可能发生的异常用 except 获取并处理</li></ul><hr><p>参考链接：</p><p><a href="http://blog.huoding.com/2016/01/19/488">浅谈 CLOSE_WAIT</a></p><p><a href="https://mp.weixin.qq.com/s?__biz=MzI4MjA4ODU0Ng==&mid=402163560&idx=1&sn=5269044286ce1d142cca1b5fed3efab1&3rd=MzA3MDU4NTYzMw==&scene=6#rd">又见 CLOSE_WAIT</a></p><p><a href="https://www.cnblogs.com/pengyusong/p/5805704.html">【原创】python requests 库底层 Sockets 处于 close_wait 状态</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在服务器上发现有大量的 CLOSE_WAIT 存在，排查发现是 Python 爬虫中 requests 导致的。&lt;/p&gt;
&lt;h3 id=&quot;1-CLOSE-WAIT&quot;&gt;&lt;a href=&quot;#1-CLOSE-WAIT&quot; class=&quot;headerlink&quot; title=&quot;1. CLOSE WAIT&quot;&gt;&lt;/a&gt;1. CLOSE WAIT&lt;/h3&gt;&lt;p&gt;简单来说，TCP 连接断开时需要进行“四次挥手”（建立连接是“三次握手”），TCP 连接的两端都可以发起关闭连接的请求，若其中一端发起了关闭连接，但另外一端没有关闭连接，那么该连接就会处于 CLOSE_WAIT 状态。&lt;/p&gt;
    
    </summary>
    
    
      <category term="linux" scheme="https://www.bytepoem.com/categories/linux/"/>
    
    
      <category term="tcp" scheme="https://www.bytepoem.com/tags/tcp/"/>
    
      <category term="linux" scheme="https://www.bytepoem.com/tags/linux/"/>
    
      <category term="python" scheme="https://www.bytepoem.com/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>在 Spring Boot 中使用 @Crossorign 注解解决跨域问题</title>
    <link href="https://www.bytepoem.com/2020/04/11/spring-boot-crossorign/"/>
    <id>https://www.bytepoem.com/2020/04/11/spring-boot-crossorign/</id>
    <published>2020-04-11T11:52:46.000Z</published>
    <updated>2020-04-20T15:37:09.782Z</updated>
    
    <content type="html"><![CDATA[<p>最近在 Spring Boot 中写 REST API 时发现前端 Ajax 调用的时候会产生跨域问题。于是乎想到用 jsonp 的方式进行解决，但是发现 <code>AbstractJsonpResponseBodyAdvice</code> 这个类在 Spring Boot 2.0 已经被废弃了，上官网发现有新姿势——<a href="https://spring.io/guides/gs/rest-service-cors/">《Enabling Cross Origin Requests for a RESTful Web Service》</a>。</p><a id="more"></a><h3 id="1-浏览器的同源政策"><a href="#1-浏览器的同源政策" class="headerlink" title="1. 浏览器的同源政策"></a>1. 浏览器的同源政策</h3><p><strong>同源策略（SOP，Same origin policy）</strong> 是由 Netscape 提出的一个著名的安全策略。所有支持 JavaScript 的浏览器都会使用这个策略。所谓同源是指，<strong>域名，协议，端口相同</strong>。即便两个不同的域名指向同一个 ip 地址，也非同源。</p><p>同源策略限制以下几种行为：</p><ul><li>1、Cookie、LocalStorage 和 IndexDB 无法读取</li><li>2、Dom 和 Js 对象无法获得</li><li>3、Ajax 请求不能发送</li></ul><p>其目的是为了保证用户信息的安全，防止恶意的网站窃取数据。举个例子：</p><ul><li>A 网站是一家银行，用户登录以后再去访问 B 网站。如果 B 网站可以读取 A 网站的 Cookie，那么 B 网站就可以利用这些信息为所欲为！（浏览器提交表单不受同源政策的限制）。</li></ul><h3 id="2-跨域解决方案"><a href="#2-跨域解决方案" class="headerlink" title="2. 跨域解决方案"></a>2. 跨域解决方案</h3><ul><li>1、jsonp（只支持 GET 请求）</li><li>2、document.domain + iframe</li><li>3、location.hash + iframe</li><li>4、window.name + iframe</li><li>5、postMessage</li><li>6、跨域资源共享（CORS）</li><li>7、nginx 代理</li><li>8、nodejs 中间件代理跨域</li><li>9、WebSocket 协议跨域</li></ul><h3 id="3-CORS"><a href="#3-CORS" class="headerlink" title="3. CORS"></a>3. CORS</h3><p>CORS 是一个 <a href="https://baike.baidu.com/item/W3C%E6%A0%87%E5%87%86">W3C 标准</a>，全称是 <strong>“跨域资源共享”（Cross-origin resource sharing）</strong>，是一种允许当前域（domain）的资源（比如 html / js / web service）被其他域（domain）的脚本请求访问的机制（利用 <a href="https://baike.baidu.com/item/XMLHTTPRequest">XMLHttpRequest</a> 请求）。由于同源策略，浏览器通常会禁止这种跨域请求。</p><p>CORS 请求分为两类：<strong>简单请求</strong>和<strong>非简单请求</strong>。</p><p>其中满足以下两大条件，就属于简单请求。</p><ul><li>请求方法是以下三种方法之一：<ul><li>HEAD</li><li>GET</li><li>POST</li></ul></li><li>HTTP 的头信息不超出以下几种字段：<ul><li>AcceptAccept-Language<ul><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于以下三个值<ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul></li></ul></li></ul></li></ul><p>不满足的为非简单请求。</p><p>浏览器对于两种请求的处理是不一样的：</p><h4 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h4><ul><li>浏览器会在简单请求的请求头中添加 <code>Origin</code> 字段，用来说明本次请求来自哪个源（协议 + 域名 + 端口）。服务器判断这个值决定是否通过这次请求</li><li>不通过时，返回头则没有 <code>Access-Control-Allow-Origin</code> 字段</li><li>通过时，则会多出以下几个字段</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http://api.baidu.com</span><br><span class="line">Access-Control-Allow-Credentials: true Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br></pre></td></tr></table></figure><h4 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h4><ul><li>在正式请求前会发送一个预检请求（OPTIONS）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS /cors HTTP/1.1 Origin: http://api.bob.comAccess-Control-Request-Method:</span><br><span class="line">PUT Access-Control-Request-Headers: X-Custom-Header Host: api.baidu.com</span><br><span class="line">Accept-Language: en-US Connection: keep-alive User-Agent: Mozilla/5.0...</span><br></pre></td></tr></table></figure><ul><li>一旦服务器通过了预检请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，返回头会多一个 <code>Origin</code> 字段以及 <code>Access-Control-Allow-Origin</code> 字段。</li></ul><h3 id="4-Crossorigin-注解"><a href="#4-Crossorigin-注解" class="headerlink" title="4.@Crossorigin 注解"></a>4.@Crossorigin 注解</h3><h4 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.CorsRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorsConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addCorsMappings</span><span class="params">(CorsRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//设置允许跨域的路径</span></span><br><span class="line">        registry.addMapping(<span class="string">"/**"</span>)</span><br><span class="line">                <span class="comment">//设置允许跨域请求的域名</span></span><br><span class="line">                .allowedOrigins(<span class="string">"*"</span>)</span><br><span class="line">                <span class="comment">//是否允许证书 不再默认开启</span></span><br><span class="line">                .allowCredentials(<span class="keyword">true</span>)</span><br><span class="line">                <span class="comment">//设置允许的方法</span></span><br><span class="line">                .allowedMethods(<span class="string">"*"</span>)</span><br><span class="line">                <span class="comment">//跨域允许时间</span></span><br><span class="line">                .maxAge(<span class="number">3600</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="局部配置"><a href="#局部配置" class="headerlink" title="局部配置"></a>局部配置</h4><p>可以注解在整个 Controller 上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span>(origins=<span class="string">"http://localhost:9000"</span>, maxAge=<span class="number">3600</span>)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestController</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>也可以注解在单个方法上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CrossOrigin</span>(origins=<span class="string">"http://localhost:9000"</span>)</span><br><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Greeting <span class="title">greeting</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"world"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以通过 <code>Filter</code> 的方式指定接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> FilterRegistrationBean <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource();</span><br><span class="line">    CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">    config.setAllowCredentials(<span class="keyword">true</span>);</span><br><span class="line">    config.addAllowedOrigin(<span class="string">"http://localhost:9000"</span>);</span><br><span class="line">    config.addAllowedOrigin(<span class="string">"null"</span>);</span><br><span class="line">    config.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">    config.addAllowedMethod(<span class="string">"*"</span>);</span><br><span class="line">    source.registerCorsConfiguration(<span class="string">"/**"</span>, config); <span class="comment">// CORS 配置对所有接口都有效</span></span><br><span class="line">    FilterRegistrationBean bean = newFilterRegistrationBean(<span class="keyword">new</span> CorsFilter(source));</span><br><span class="line">    bean.setOrder(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h3><p>新建另外一个 web 项目，此项目端口为 9000，即我们前面设置的 <code>origin</code> ，而 api 项目的端口为 8080。</p><p>其中主要代码如下：</p><p><code>public/hello.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">"http://localhost:8080/hello"</span>,</span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">data, status, jqxhr</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">".greeting-test"</span>).append(data);</span><br><span class="line">    <span class="built_in">console</span>.log(jqxhr);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>public/index.html</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Hello CORS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"hello.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">"greeting-test"</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>请求成功时即可看到返回结果。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello world</span><br></pre></td></tr></table></figure><hr><p>参考链接：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解 —— 阮一峰</a></li><li><a href="https://spring.io/guides/gs/rest-service-cors/">《Enabling Cross Origin Requests for a RESTful Web Service》</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在 Spring Boot 中写 REST API 时发现前端 Ajax 调用的时候会产生跨域问题。于是乎想到用 jsonp 的方式进行解决，但是发现 &lt;code&gt;AbstractJsonpResponseBodyAdvice&lt;/code&gt; 这个类在 Spring Boot 2.0 已经被废弃了，上官网发现有新姿势——&lt;a href=&quot;https://spring.io/guides/gs/rest-service-cors/&quot;&gt;《Enabling Cross Origin Requests for a RESTful Web Service》&lt;/a&gt;。&lt;/p&gt;
    
    </summary>
    
    
      <category term="spring boot" scheme="https://www.bytepoem.com/categories/spring-boot/"/>
    
    
      <category term="spring boot" scheme="https://www.bytepoem.com/tags/spring-boot/"/>
    
      <category term="java" scheme="https://www.bytepoem.com/tags/java/"/>
    
  </entry>
  
</feed>
